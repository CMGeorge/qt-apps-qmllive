/****************************************************************************
**
** Copyright (C) 2019 Luxoft Sweden AB
** Copyright (C) 2018 Pelagicore AG
** Contact: https://www.qt.io/licensing/
**
** This file is part of the QmlLive tool.
**
** $QT_BEGIN_LICENSE:GPL-QTAS$
** Commercial License Usage
** Licensees holding valid commercial Qt Automotive Suite licenses may use
** this file in accordance with the commercial license agreement provided
** with the Software or, alternatively, in accordance with the terms
** contained in a written agreement between you and The Qt Company.  For
** licensing terms and conditions see https://www.qt.io/terms-conditions.
** For further information use the contact form at https://www.qt.io/contact-us.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3 or (at your option) any later version
** approved by the KDE Free Qt Foundation. The licenses are as published by
** the Free Software Foundation and appearing in the file LICENSE.GPL3
** included in the packaging of this file. Please review the following
** information to ensure the GNU General Public License requirements will
** be met: https://www.gnu.org/licenses/gpl-3.0.html.
**
** $QT_END_LICENSE$
**
** SPDX-License-Identifier: GPL-3.0
**
****************************************************************************/

/*!

\page qmllive-concepts.html
\title Concepts

The following are some concepts that are helpful to understand QmlLive.

\list
   \li \l{Live Reloading}
   \li \l{Local Sessions}
   \li \l{Display, Screens, Panels, Components, Fragments}
   \li \l{Remote Sessions}
   \li \l{UXSheets}
\endlist

\section1 Live Reloading

In a typical User Interface (UI) design phase, designers create many graphical
files describing their ideal UI. Transferring these graphical visions into
source code that runs, is a challenging and time consuming task.

\image workbench.png

This task also involves compromises between the designers and the developers.
Sometimes, the designer's vision cannot be replicated fully with the underlying
technology. Consequently, this task requires many iterations before there is
an optimal solution.

There is a lot of time consuming editing work needed, to reach a compromise
that satisfies the designer's vision and how the developer realizes it in code.
Each iteration is a small step towards the desired user experience goal. Qt,
with the Qt Quick technology, already shortens the gap between vision and
product via QML, a more design oriented language. QmlLive aims to close this
gap.

QmlLive is managed by a central Bench that watches your project workspace. A
change in a file inside the workspace is automatically detected and immediately
reflected onto one or more local rendering areas, or to connected remote
clients. A team can develop a UI quickly and precisely on a machine and
simultaneously display it on one or more local and/or remote clients. These
clients can run on any desktop or networked embedded device that supports Qt5
and QmlLive.

\image concept.png

\section1 Local Sessions

For a local session you only need the QmlLive Bench. It contains all of the
required components in an easy-to-use interface. As you type and save, the
output is displayed on your machine in a fraction of a second. Local sessions
are best suited for a multi-monitor setup where you see your code on one
display and the live results of your changes on another display. This
use case is ideal for sketching out a scene or putting final touches to
animation behavior. Local sessions also encourage you to think in terms of
elements; instead of developing a whole scene, you can break the scene into
smaller elements. As you work on these small elements, you can see how they
look standalone or embedded into a larger scene.

\image client.png


\section1 Remote Sessions

A scene rendered on a machine's display rarely looks the same as on the target
display for an embedded device. There are subtle changes in the color
appearance, pixel density, font rendering, and proportions. So it is vital to
ensure that a user experience designed on a machine looks just as good on the
embedded device. In the past, this used to be a cumbersome process, requiring
that you copy the code to the embedded device and restart the application. With
QmlLive Bench and QmlLive Runtime you connect to the device, propagate your
workspace, and from there on all changes are reflected on the device's display.
You can always connect more devices, or devices with different sizes.

\image runtime.png

\section1 Display, Screens, Panels, Components, Fragments

\code
+- Display
   |
   +- Panel
   |
   +- Screen
      |
      +- Panel
         |
         +- Component
            |
            +- Fragment
\endcode

To better structure a UI, we \assume a hierarchy of UI elements. For simplicity
we name them \e display, \e screen, \e panel, \e component, and \e fragment.
These elements form a hierarchy from large UI elements to the smaller entities
and internals. The main benefit of this hierarchy, is that it allows us to
share a common vocabulary with our customers and ensures the design is always
aligned with this shared definition.

These elements are defined as follows:

\list
   \li display - The root element that contains a collection of screens or
       panels, where each screen covers the entire physical display.
   \li screen - Consists of several panels that provide the visual structure
       as defined by the design team.
   \li panel - Each panel consists of a set of components.
   \li components - Reusable UI elements that contain fragments.
   \li fragments - An internal structure UI element, not exposed to the
       UI developer.
\endlist

Designing a UI requires an understanding of the initial display layout
and its screen navigation structure, and of the structure of individual screens and
their panels. It is also required to define a common set of components to be used inside
the panels. The fragments are implementation-specific.

\section1 UXSheets

Over time, developing applications in QML can become complex, especially if
it is not clear how elements are isolated; this is also true for designing UIs.
To translate the designer's vision into a developer's code, the vision needs
to be broken into UI elements like screen, panel, components, and so on. Then,
these elements need to be further validated on their own; before being translated
into source code.

To connect this vision to a developer's workflow, you can implement a graphics
sheet directly with Qt Quick, as a series of standalone documents, collectively
called a UXSheet. These sheets act as interfaces between the designer and the
developer. The screen below shows how a sample sheet could look.

*/
